---
import Layout from "./Layout.astro";
import { shortTradeEnum } from "@models/estimateOptions";
import type { z } from "zod";

/**
 * Props interface for the EstimateWrapper component
 * @property {string} title - The page title to be displayed in the browser
 * @property {string} estimateType - The type of estimate being processed
 */
interface Props {
  title: string;
  estimateType: string;
}

/**
 * Validates the estimate type and returns the parsed data or triggers a redirect
 * @param {string} estimateType - The estimate type to validate
 * @returns {z.infer<typeof shortTradeEnum> | Response} Parsed estimate type or redirect response
 */
function validateEstimateType(
  estimateType: string
): z.infer<typeof shortTradeEnum> | Response {
  const parseResult = shortTradeEnum.safeParse(estimateType);

  if (!parseResult.success) {
    // Log validation error for debugging (optional)
    console.error("Invalid estimate type:", parseResult.error);

    return new Response(null, {
      status: 302,
      headers: { Location: "/" },
    });
  }

  return parseResult.data;
}

const ipAddress =
  Astro?.request?.headers?.get("cf-connecting-ip") ||
  Astro?.request?.headers?.get("x-real-ip") ||
  Astro?.request?.headers?.get("x-forwarded-for")?.split(",")[0] ||
  null;

// Destructure props with default values if needed
const { title, estimateType: rawEstimateType } = Astro.props;
// Validate the estimate type
const validationResult = validateEstimateType(rawEstimateType);

// Handle redirect if validation failed
if (validationResult instanceof Response) {
  return validationResult;
}
---

<estimate-wrapper estimateType={validationResult}>
  <div data-ip-address={ipAddress} id="ipAddress"></div>
  <Layout title={title} data-estimate-type={validationResult}>
    <slot />
  </Layout>
</estimate-wrapper>

<script>
  import type { ShortTradeEnum } from "@models/estimateOptions";
  import {
    estimateProgressStore,
    resetEstimateProgressFields,
  } from "@stores/estimateProgress";
  import {
    estimateStepsStore,
    type EstimateStepsState,
  } from "@stores/estimateStepsStore";
  import { crossPlatformLoader } from "@utils/crossPlatformLoader";
  import { appendQueryParams } from "@utils/queryParams";
  import { supabase } from "@utils/supabase";
  import { navigate } from "astro:transitions/client";
  import posthog from "posthog-js";
  import {
    estimateSteps,
    getCurrentStepIndex,
    getFirstStep,
    getTotalSteps,
  } from "src/consts/estimateSteps";

  const searchParams = new URLSearchParams(window.location.search);

  // Check if reset parameter is true
  const shouldReset = searchParams.get("reset") === "true";
  if (shouldReset) {
    // Reset all stores
    const ipAddress =
      document.querySelector("#ipAddress")?.getAttribute("data-ip-address") ||
      null;
    await resetEstimateProgressFields(ipAddress);

    // Remove the reset parameter from the URL
    const url = new URL(window.location.href);
    url.searchParams.delete("reset");

    // Replace the current URL without reloading the page
    window.history.replaceState({}, document.title, url.toString());
  }

  class EstimateWrapper extends HTMLElement {
    private previousStep: string | null = null;

    connectedCallback() {
      // Read the message from the data attribute.
      const state: EstimateStepsState = JSON.parse(
        this.dataset.estimateStepsStore || " {}"
      );

      // estimateStepsStore.subscribe((state) => {
      const { currentStep, estimateType } = estimateStepsStore.get();

      // Only send events when currentStep changes, is not null, and estimateType is available
      if (
        currentStep !== null &&
        currentStep !== this.previousStep &&
        estimateType
      ) {
        this.previousStep = currentStep;

        // Get step information
        const currentStepIndex = getCurrentStepIndex(estimateType, currentStep);
        const totalSteps = getTotalSteps(estimateType) + 1;
        const allStepsString = estimateSteps[estimateType].join(", ");

        const posthogStepViewedEvent = {
          estimate_type: estimateType,
          timestamp: new Date().toISOString(),
          step_name: currentStep,
          step_number: currentStepIndex + 1,
          total_step_count: totalSteps,
          all_steps: allStepsString,
        };

        // Send PostHog event
        posthog.capture("form_step_viewed", posthogStepViewedEvent);
        console.log("posthogStepViewedEvent", posthogStepViewedEvent);
      }
    }
  }

  customElements.define("estimate-wrapper", EstimateWrapper);

  crossPlatformLoader(() => {
    // Update user agent directly in the store
    const existingStore = estimateProgressStore.get();

    const estimateType =
      document
        .querySelector("[data-estimate-type]")
        ?.getAttribute("data-estimate-type") || "";

    if (!existingStore.id && !shouldReset) {
      // Determine first step based on estimate type
      let firstStep = getFirstStep(estimateType as ShortTradeEnum);

      const searchParams = new URLSearchParams(window.location.search);

      searchParams.append("reset", "true");

      // Redirect to first step with query params preserved
      const redirectUrl = `/estimate/${estimateType}/${firstStep}`;
      return navigate(appendQueryParams(redirectUrl, searchParams));
    }

    estimateProgressStore.set({
      ...existingStore,
      estimate_type: estimateType,
    });
  });

  // Debounce function to limit how often the callback is executed
  const debounce = <T extends (...args: any[]) => void>(
    func: T,
    wait = 300
  ) => {
    let timeout: ReturnType<typeof setTimeout> | undefined;
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  };

  // Debounced logging function
  const debouncedSave = debounce(async (state: any) => {
    if (!state.id) return;

    await supabase.from("leads").upsert({
      id: state.id,
      updated_at: new Date().toISOString(),
      ...state,
    });
  }, 500);

  estimateProgressStore.subscribe(debouncedSave);
</script>
