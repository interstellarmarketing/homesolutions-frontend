---
import Layout from "./Layout.astro";
import { shortTradeEnum } from "@assets/info/estimateOptions";
import { estimateStepsStore } from "@stores/estimateStepsStore";
import type { z } from "zod";

/**
 * Props interface for the EstimateWrapper component
 * @property {string} title - The page title to be displayed in the browser
 * @property {string} estimateType - The type of estimate being processed
 */
interface Props {
  title: string;
  estimateType: string;
}

/**
 * Validates the estimate type and returns the parsed data or triggers a redirect
 * @param {string} estimateType - The estimate type to validate
 * @returns {z.infer<typeof shortTradeEnum> | Response} Parsed estimate type or redirect response
 */
function validateEstimateType(
  estimateType: string
): z.infer<typeof shortTradeEnum> | Response {
  const parseResult = shortTradeEnum.safeParse(estimateType);

  if (!parseResult.success) {
    // Log validation error for debugging (optional)
    console.error("Invalid estimate type:", parseResult.error);

    return new Response(null, {
      status: 302,
      headers: { Location: "/" },
    });
  }

  return parseResult.data;
}

// Destructure props with default values if needed
const { title, estimateType: rawEstimateType } = Astro.props;
// Validate the estimate type
const validationResult = validateEstimateType(rawEstimateType);

// Handle redirect if validation failed
if (validationResult instanceof Response) {
  return validationResult;
}
---

<estimate-wrapper
  data-estimate-steps-store={JSON.stringify(estimateStepsStore.get())}
  estimateType={validationResult}
>
  <Layout title={title} data-estimate-type={validationResult}>
    <slot />
  </Layout>
</estimate-wrapper>

<script>
  import { estimateStore, resetEstimateFields } from "@stores/estimateProgress";
  import { type EstimateStepsState } from "@stores/estimateStepsStore";
  import { crossPlatformLoader } from "@utils/crossPlatformLoader";
  import posthog from "posthog-js";
  import {
    estimateSteps,
    getCurrentStepIndex,
    getTotalSteps,
  } from "src/consts/estimateSteps";

  const searchParams = new URLSearchParams(window.location.search);

  // Check if reset parameter is true
  const shouldReset = searchParams.get("reset") === "true";
  if (shouldReset) {
    // Reset all stores
    resetEstimateFields();

    // Remove the reset parameter from the URL
    const url = new URL(window.location.href);
    url.searchParams.delete("reset");

    // Replace the current URL without reloading the page
    window.history.replaceState({}, document.title, url.toString());
  }

  const trackingParams = {
    utm_source: searchParams.get("utm_source") || undefined,
    utm_medium: searchParams.get("utm_medium") || undefined,
    utm_campaign: searchParams.get("utm_campaign") || undefined,
    utm_content: searchParams.get("utm_content") || undefined,
    utm_term: searchParams.get("utm_term") || undefined,
    fbclid: searchParams.get("fbclid") || undefined,
    gclid: searchParams.get("gclid") || undefined,
    wbraid: searchParams.get("wbraid") || undefined,
    gbraid: searchParams.get("gbraid") || undefined,
    ssn: searchParams.get("ssn") || undefined,
  };

  // Update store with tracking params
  const existingStore = estimateStore.get();
  estimateStore.set({
    ...existingStore,
    trackingParams: {
      ...existingStore.trackingParams,
      ...Object.fromEntries(
        Object.entries(trackingParams).filter(([_, v]) => v !== undefined)
      ),
    },
  });

  class EstimateWrapper extends HTMLElement {
    private previousStep: string | null = null;

    connectedCallback() {
      // Read the message from the data attribute.
      const state: EstimateStepsState = JSON.parse(
        this.dataset.estimateStepsStore || " {}"
      );

      // estimateStepsStore.subscribe((state) => {
      const { currentStep, estimateType } = state;

      // Only send events when currentStep changes, is not null, and estimateType is available
      if (
        currentStep !== null &&
        currentStep !== this.previousStep &&
        estimateType
      ) {
        this.previousStep = currentStep;

        // Get step information
        const currentStepIndex = getCurrentStepIndex(estimateType, currentStep);
        const totalSteps = getTotalSteps(estimateType) + 1;
        const allStepsString = estimateSteps[estimateType].join(", ");

        const posthogStepViewedEvent = {
          estimate_type: estimateType,
          timestamp: new Date().toISOString(),
          step_name: currentStep,
          step_number: currentStepIndex + 1,
          total_step_count: totalSteps,
          all_steps: allStepsString,
        };

        // Send PostHog event
        posthog.capture("form_step_viewed", posthogStepViewedEvent);
      }
    }
  }

  customElements.define("estimate-wrapper", EstimateWrapper);

  crossPlatformLoader(() => {
    // Update user agent directly in the store
    const existingStore = estimateStore.get();
    const existingTrackingParams = existingStore.trackingParams || {};

    const estimateType =
      document
        .querySelector("[data-estimate-type]")
        ?.getAttribute("data-estimate-type") || "";

    estimateStore.set({
      ...existingStore,
      estimateType,
      trackingParams: {
        ...existingTrackingParams,
        userAgent: window.navigator.userAgent,
      },
    });
  });

  estimateStore.subscribe((state) => {
    console.log(state);
  });
</script>
