---
import { shortTradeEnum } from "@models/estimateOptions";
import StepLayout from "@components/step-layout/index.astro";
import { getCurrentStepNumber, getTotalSteps } from "@consts/estimateSteps";
import EstimateWrapper from "@layouts/EstimateWrapper.astro";
import { ProcessEstimateType } from "@utils/kv/estimateTypeReset";
import { formSubmissionParser } from "be-rpc-estimates/src/zoddles/form-submission/formSubmissionType";
import { z } from "zod";
// Validation schemas
const zipSchema = formSubmissionParser.pick({ zipCode: true });
const estimateTypeSchema = shortTradeEnum;

interface PageState {
  estimateType: string;
  zipCode: string | null;
  stepNumber: number;
  totalSteps: number;
}

// Initialize page state
async function initializePage(
  params: Record<string, string | undefined>,
  runtime: any
): Promise<PageState | Response> {
  // Validate estimate type from URL params
  const parsedEstimateType = estimateTypeSchema.safeParse(params.estimateType);

  if (!params.estimateType || !parsedEstimateType.success) {
    console.error("Invalid estimate type");
    return new Response(null, {
      status: 302,
      headers: { Location: "/" },
    });
  }

  const validatedEstimateType = parsedEstimateType.data;
  ProcessEstimateType(validatedEstimateType);

  // Get user location from Cloudflare
  const cfPostalCode = z.string().safeParse(runtime.cf?.postalCode);

  // Initialize zip code from URL param or Cloudflare location
  const zipCode = cfPostalCode.success ? cfPostalCode.data : null;

  // Get step information
  const estimateType = parsedEstimateType.data;
  const stepNumber = getCurrentStepNumber(estimateType, "zip");
  const totalSteps = getTotalSteps(estimateType);

  return {
    estimateType: validatedEstimateType,
    zipCode,
    stepNumber,
    totalSteps,
  };
}

// Process the page based on the request method
let pageState: PageState | Response;

pageState = await initializePage(Astro.params, Astro.locals.runtime);

if (pageState instanceof Response) {
  return pageState;
}

// Helper function to format estimate type display
const formatEstimateTypeNoun = (type: string) =>
  type.endsWith("s") ? type.slice(0, -1) : type;
---

<EstimateWrapper
  title={pageState.estimateType}
  estimateType={pageState.estimateType}
>
  <form id="zipForm" data-estimate-type={pageState.estimateType}>
    <StepLayout
      stepHeader={`Let's find your local ${formatEstimateTypeNoun(pageState.estimateType)} pros`}
      stepNumber={pageState.stepNumber}
      totalSteps={pageState.totalSteps}
      hasNextStep={pageState.stepNumber <= pageState.totalSteps}
      hasPrevStep={pageState.stepNumber > 1}
      estimateType={pageState.estimateType}
      loadingButtonText="Validating your zip code..."
    >
      <div class="flex flex-col gap-4 text-center rounded-lg container">
        <h2 class="text-xl font-black"></h2>

        <div
          class="flex flex-col items-start text-center gap-4 w-full mx-auto max-w-md"
        >
          <!-- Hidden TrustedForm fields -->
          <input type="hidden" name="xxTrustedFormCertUrl" />
          <input type="hidden" name="xxTrustedFormPingUrl" />

          <p class="text-[#111928] text-sm font-medium leading-[21px]">
            Enter the location of your project
          </p>

          <div class="w-full relative">
            <img
              src="/static/map-pin-alt.svg"
              alt="location pin"
              class="absolute left-4 top-1/2 -translate-y-1/2"
            />
            <input
              type="text"
              required
              id="zipInput"
              name="zipInput"
              placeholder="Enter your zip code"
              value={pageState.zipCode ?? null}
              class="w-full h-[52px] pl-14 pr-4 py-3.5 bg-gray-50 rounded-lg border border-gray-300 text-gray-500 text-base font-normal leading-normal"
              minlength="5"
              maxlength="5"
              pattern="[0-9]{5}"
              inputmode="numeric"
            />
          </div>
          <div id="zipErrorMessage" class="text-red-500 text-sm mt-1 hidden">
          </div>
        </div>
      </div>
    </StepLayout>
  </form>
</EstimateWrapper>

<script>
  import { shortTradeEnum } from "@models/estimateOptions";
  import { getNextStep } from "@consts/index";
  import { estimateProgressStore } from "@stores/estimateProgress";
  import { estimateStepsStore } from "@stores/estimateStepsStore";
  import { crossPlatformLoader } from "@utils/crossPlatformLoader";
  import { actions } from "astro:actions";
  import { z } from "zod";
  import { navigate } from "astro:transitions/client";
  import { appendQueryParams } from "@utils/queryParams";

  const ZIP_LENGTH = 5;

  const validators = {
    zipString: z.string().length(ZIP_LENGTH),
    zipNumber: z.coerce.number(),
  };

  class ZipFormValidator {
    private zipInput: HTMLInputElement;
    private submitButton: HTMLButtonElement;
    private form: HTMLFormElement;
    private estimateType: string;

    constructor() {
      this.zipInput = document.getElementById("zipInput") as HTMLInputElement;
      this.submitButton = document.getElementById(
        "nextStepButton"
      ) as HTMLButtonElement;
      this.form = document.getElementById("zipForm") as HTMLFormElement;
      this.estimateType =
        document
          .querySelector("[data-estimate-type]")
          ?.getAttribute("data-estimate-type") || "";

      if (
        this.zipInput &&
        this.submitButton &&
        this.form &&
        this.estimateType
      ) {
        this.initialize();
      }
    }

    private initialize() {
      const validatedEstimateType = shortTradeEnum.safeParse(this.estimateType);
      if (!validatedEstimateType.success) {
        console.error("Invalid estimate type");
        return;
      }

      // Initialize stores
      estimateStepsStore.set({
        currentStep: "zip",
        estimateType: validatedEstimateType.data,
      });

      // Check initial value
      if (this.zipInput.value) {
        const isValid =
          validators.zipString.safeParse(this.zipInput.value).success &&
          validators.zipNumber.safeParse(this.zipInput.value).success;

        this.toggleSubmitButton(isValid);
      }

      // Set up event listeners
      this.zipInput.addEventListener("input", (event) => {
        const input = (event.target as HTMLInputElement).value;
        this.validateZipCode(input);

        // Clear error message when user starts typing
        const errorElement = document.getElementById("zipErrorMessage");
        if (errorElement) {
          errorElement.classList.add("hidden");
        }
        this.zipInput.setCustomValidity("");
      });

      // Handle form submission
      this.form.addEventListener("submit", (e) => this.handleSubmit(e));
    }

    private validateZipCode(input: string) {
      const isValid =
        validators.zipString.safeParse(input).success &&
        validators.zipNumber.safeParse(input).success;

      this.toggleSubmitButton(isValid);
    }

    private toggleSubmitButton(isValid: boolean) {
      if (isValid) {
        this.submitButton.setAttribute("aria-disabled", "false");
      } else {
        this.submitButton.setAttribute("aria-disabled", "true");
      }
    }

    private async handleSubmit(e: Event) {
      e.preventDefault();

      const zipCheck = await actions.checkZip({ zipCode: this.zipInput.value });

      if (!zipCheck.data) {
        this.zipInput.setCustomValidity("Invalid ZIP code");
        // Display the error message
        const errorElement = document.getElementById("zipErrorMessage");
        if (errorElement) {
          errorElement.textContent = "Invalid ZIP code";
          errorElement.classList.remove("hidden");
          e.preventDefault(); // Prevent form submission
        }
        return;
      }

      // Clear any previous error
      this.zipInput.setCustomValidity("");
      const errorElement = document.getElementById("zipErrorMessage");
      if (errorElement) {
        errorElement.classList.add("hidden");
      }

      // We'll let the form submit to the server for ZIP validation
      // but we'll update the store with current values
      const existingStore = estimateProgressStore.get();
      const formData = new FormData(this.form);

      // Get TrustedForm data
      const trustedFormCertUrl =
        document
          .querySelector('[name="xxTrustedFormCertUrl"]')
          ?.getAttribute("value") || "";
      const trustedFormPingUrl =
        document
          .querySelector('[name="xxTrustedFormPingUrl"]')
          ?.getAttribute("value") || "";

      // Update store with zipCode and estimateShortTrade
      estimateProgressStore.set({
        ...existingStore,
        zip_code: this.zipInput.value,
        estimate_type: this.estimateType,
        trusted_form_cert_url: trustedFormCertUrl || undefined,
        trusted_form_ping_url: trustedFormPingUrl || undefined,
      });

      // Get next step
      const validatedEstimateType = shortTradeEnum.safeParse(this.estimateType);
      if (validatedEstimateType.success) {
        const nextStep = getNextStep(validatedEstimateType.data, "zip");
        if (nextStep) {
          const currentUrl = new URL(window.location.href);
          navigate(
            appendQueryParams(
              `/estimate/${this.estimateType}/${nextStep}`,
              new URLSearchParams(currentUrl.search)
            )
          );
          return;
        }
      }
    }
  }

  crossPlatformLoader(() => new ZipFormValidator());
</script>
