---
/**
 * Estimate Action Page
 *
 * This page handles the selection of specific actions for different types of estimates.
 * It's part of a multi-step estimate process that includes:
 * 1. Estimate type selection
 * 2. ZIP code validation
 * 3. Action selection (current page)
 * 4. Project details
 */

import { z } from "zod";
import { estimateStore } from "@stores/estimateProgress";
import {
  shortTradeEnum,
  tradeOptionDescriptions,
} from "@assets/info/estimateOptions";
import {
  activeEstimateTypeStore,
  computedEstimateOptions,
} from "@stores/activeEstimateType";
import {
  estimateStepsStore,
  getNextStep,
  getPreviousStep,
  getCurrentStepNumber,
  getTotalSteps as getStoreSteps,
} from "@stores/estimateStepsStore";
import EstimateWrapper from "@layouts/EstimateWrapper.astro";
import { getTotalSteps } from "@utils/layout";
import StepLayout from "@components/step-layout/index.astro";
import { appendQueryParams } from "@utils/queryParams";
// Schema definitions
const actionSchema = z.string();
const estimateTypeSchema = shortTradeEnum;

// Extract and validate URL parameters
const { estimateType: rawEstimateType } = Astro.params;
const estimateTypeResult = estimateTypeSchema.safeParse(rawEstimateType);

// Redirect to home if estimate type is invalid
if (!rawEstimateType || !estimateTypeResult.success) {
  return Astro.redirect("/");
}

const estimateType = estimateTypeResult.data;

// Get store data
const existingStore = estimateStore.get();
const activeEstimateType = activeEstimateTypeStore.get();
const activeEstimateOptions = computedEstimateOptions.get();

// Update the estimate steps store with current page
estimateStepsStore.set({
  currentStep: "action",
  estimateType: estimateType,
});

// Validation checks
if (!activeEstimateOptions) {
  console.error("Missing active estimate options");
  return Astro.redirect("/");
}

if (!existingStore?.zipCode?.length) {
  return Astro.redirect(`/estimate/${estimateType}/zip`);
}

// Get trade-specific options
const tradeOptions = tradeOptionDescriptions.find(
  (trade) => trade.shortTrade === activeEstimateType
);

// Handle form submission
if (Astro.request.method === "POST") {
  try {
    const formData = await Astro.request.formData();
    const action = actionSchema.parse(formData.get("action"));

    estimateStore.set({
      ...existingStore,
      estimateAction: action,
    });

    // Get the next step from the store
    const nextStep = getNextStep(estimateType, "action");

    if (nextStep) {
      const redirectUrl = `/estimate/${estimateType}/${nextStep}`;
      return new Response(null, {
        status: 302,
        headers: {
          Location: appendQueryParams(redirectUrl, Astro.url.searchParams),
        },
      });
    }

    // Fallback to original logic if next step not found
    if (estimateType === "roofing") {
      const redirectUrl = `/estimate/${estimateType}/home-type`;
      return Astro.redirect(
        appendQueryParams(redirectUrl, Astro.url.searchParams)
      );
    }

    return Astro.redirect(`/estimate/${estimateType}/project-details`);
  } catch (error) {
    console.error("Form submission error:", error);
    // Could add error handling here
  }
}

// Get step number and total steps from the store
const stepNumber = getCurrentStepNumber(estimateType, "action");
const totalSteps = getStoreSteps(estimateType);

const getStepHeader = () => {
  switch (estimateType) {
    case "roofing":
      return tradeOptions?.actionDescription ?? "";
    default:
      return "What type of project are you looking to complete?";
  }
};

const stepHeader = getStepHeader();

console.log(existingStore.estimateAction);
---

<EstimateWrapper title={estimateType} estimateType={estimateType}>
  <form method="post">
    <!-- Add hidden input for initial state -->
    <input
      type="hidden"
      id="hasInitialSelection"
      value={existingStore.estimateAction ? "true" : "false"}
    />

    <StepLayout
      stepHeader={stepHeader}
      stepNumber={stepNumber}
      totalSteps={totalSteps}
      estimateType={estimateType}
      hasNextStep
      hasPrevStep={stepNumber > 1}
    >
      <div class="flex flex-col gap-4 text-center rounded-lg container">
        <div class="grid grid-cols-2 gap-4">
          {
            activeEstimateOptions.data.estimateAction.map(
              (actionOption, index) => {
                return (
                  <label class="inline-flex items-center ">
                    <input
                      type="radio"
                      name="action"
                      checked={existingStore.estimateAction === actionOption}
                      value={actionOption}
                      class="hidden peer"
                    />
                    <span class="w-full h-full px-5 py-2.5 rounded-lg bg-[#F9FAFB] border border-[#E5E7EB] text-[#2D3748] text-sm font-medium leading-[21px] cursor-pointer peer-checked:bg-[#2D3748] peer-checked:text-white peer-checked:border-[#E5E7EB] transition-colors flex justify-center items-center gap-2 capitalize">
                      {actionOption}
                    </span>
                  </label>
                );
              }
            )
          }
        </div>
      </div>
    </StepLayout>
  </form>

  <script>
    /**
     * Client-side form validation and button state management
     */
    class FormController {
      private radioButtons: NodeListOf<HTMLInputElement>;
      private submitButton: HTMLButtonElement | null;

      constructor() {
        this.radioButtons = document.querySelectorAll('input[name="action"]');
        this.submitButton = document.getElementById(
          "nextStepButton"
        ) as HTMLButtonElement;
        this.initialize();
      }

      private initialize() {
        if (!this.submitButton || !this.radioButtons.length) return;

        // Check hidden field for initial state
        const hasInitialSelection =
          document
            .getElementById("hasInitialSelection")
            ?.getAttribute("value") === "true";
        if (hasInitialSelection) {
          this.submitButton.disabled = false;
        }

        this.radioButtons.forEach((radio) => {
          radio.addEventListener("change", () => this.handleRadioChange());
        });
      }

      private handleRadioChange() {
        if (!this.submitButton) return;
        const isSelected = Array.from(this.radioButtons).some(
          (radio) => radio.checked
        );
        this.submitButton.disabled = !isSelected;
      }
    }

    new FormController();
  </script>
</EstimateWrapper>
